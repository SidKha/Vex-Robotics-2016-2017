#pragma config(Motor,  port1,           lol,           tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           fld,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           bld,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           frd,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           brd,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           lLift1,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           lLift2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rLift1,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rLift2,        tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"

// Function prototypes
void drive();
void detectButtons();
void moveArm(int direction);
//void shakeArm(int times);
void moveDrive(int leftPow, int rightPow);

// Global variables
const float SPEED_ADJUST = 1.5;
const float SPEED_ADJUST_LEFT = 1.7;

void pre_auton() {
	bStopTasksBetweenModes = true;
}

task autonomous() {
	// Do some stuff
	motor[fld] = -127;
	motor[bld] = -127;
	motor[frd] = -69;
	motor[brd] = -69;
	wait1Msec(1000);
	motor[fld] = 0;
	motor[bld] = 0;
	motor[frd] = 0;
	motor[brd] = 0;
	motor[port1] = 110;
	wait1Msec(1000);
	motor[port1] = 0;
	motor[fld] = -127;
	motor[bld] = -127;
	motor[frd] = -87;
	motor[brd] = -87;
	wait1Msec(1500);
	motor[fld] = 0;
	motor[bld] = 0;
	motor[frd] = 0;
	motor[brd] = 0;
	motor[fld] = -127;
	motor[bld] = 127;
	motor[frd] = 127;
	motor[brd] = -127;
	wait1Msec(4000);
	motor[fld] = 0;
	motor[bld] = 0;
	motor[frd] = 0;
	motor[brd] = 0;	
}

// Do stuff

task usercontrol() {
	while(true) {
	if (vexRT[Btn5D] == 1){
	motor[lol] = -95;
	}else{
	motor[lol] = 0;
}
		drive();
		detectButtons();
	}
}

void drive() {
	int leftSpeed = vexRT[Ch3] / SPEED_ADJUST_LEFT,
	    rightSpeed = vexRT[Ch2] / SPEED_ADJUST;
	moveDrive(leftSpeed, rightSpeed);
}

void moveDrive(int leftPow, int rightPow) {
	// Move the left side of the robot
	motor[fld] = leftPow;
	motor[bld] = leftPow;
	// Move the right side of the robot
	motor[frd] = rightPow;
	motor[brd] = rightPow;
}

void detectButtons() {
	moveArm(vexRT[Btn5U]);
	moveArm(-vexRT[Btn6U]);
}


void moveArm(int direction) {
	int power = 127 * direction;
	motor[lLift1] = power;
	motor[lLift2] = power;
	motor[rLift1] = power;
	motor[rLift2] = power;
}

/*void shakeArm(int times) {
	for (int i = 0; i < (times /2); i++) {
		moveArm(1);
		moveDrive(127, 127);
		wait1Msec(3000);
		moveArm(-1);
		moveDrive(-127, -127);
		wait1Msec(3000);
	}
}*/
